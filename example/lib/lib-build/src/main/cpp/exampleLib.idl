interface TestObjectClass {
    void TestObjectClass();
    attribute long intValue;
    attribute float floatValue;
};

interface TestAttributeArrayClass {
    void TestAttributeArrayClass();
    [BoundsChecked] attribute long[] intArray;
    attribute float[] floatArray;
    attribute byte[] byteArray;
    attribute boolean[] boolArray;
    [Value] attribute TestObjectClass[] valueObjectArray;
    attribute TestObjectClass[] pointerObjectArray;
};

interface TestAttributeClass {
    void TestAttributeClass();
    readonly attribute long readOnlyIntValue;
    attribute long intValue;
    attribute float floatValue;
    attribute double doubleValue;
    attribute boolean boolValue;
    attribute any voidPointer;
    [Value] attribute TestObjectClass valueObject;
    attribute TestObjectClass pointerObject;
    attribute TestObjectClass nullPointerObject;
    [Value] attribute IDLString strParam;
};

[NoDelete]
interface TestStaticAttributeClass {
    static attribute long staticIntValue;
    static readonly attribute long staticConstIntValue;
    static attribute float staticFloatValue;
    static attribute double staticDoubleValue;
    static attribute boolean staticBoolValue;
};

interface TestConstructorClass {
    [Value] attribute IDLString strParam;

    void TestConstructorClass(long intParam);
    void TestConstructorClass(float floatParam, [Const] DOMString strParam);
    void TestConstructorClass(long intParam, long intParam2, float floatParam, float floatParam2, optional boolean boolParam);
    void TestConstructorClass(long intParam, long[] intArray, float[] floatArray);
};

interface TestMethodClass {
    void TestMethodClass();
    void setMethod01(long intParam);
    void setMethod02(float floatParam, boolean boolParam);
    void setMethod03(long intParam, long intParam2, float floatParam, float floatParam2, optional boolean boolParam);
    void setMethod04(long intParam, long[] intArray, float[] floatArray);
    void setMethod05([Const] DOMString strParam);
    void setMethod06([Const] TestObjectClass pointerObject01, TestObjectClass pointerObject02, [Const, Ref] TestObjectClass refObject01, [Ref] TestObjectClass refObject02);

    long getIntParam();
    long getIntParam2();
    float getFloatParam();
    float getFloatParam2();
    float getBoolParam();
    [Const, Value] IDLStringView getStrParam();
    [Const] TestObjectClass getPointerObject01();
    TestObjectClass getPointerObject02();
    [Const, Ref] TestObjectClass getRefObject01();
    [Ref] TestObjectClass getRefObject02();
    [Value] TestObjectClass getValueObject();
};

[NoDelete]
interface TestStaticMethodClass {
    static void setMethod01(long intParam);
    static void setMethod02(float floatParam, boolean boolParam);
    static void setMethod03(long intParam, long intParam2, float floatParam, float floatParam2, optional boolean boolParam);
    static void setMethod04(long intParam, long[] intArray, float[] floatArray);
    static void setMethod05([Const] DOMString strParam);
    static void setMethod06([Const] TestObjectClass pointerObject01, TestObjectClass pointerObject02, [Const, Ref] TestObjectClass refObject01, [Ref] TestObjectClass refObject02);

    static long getIntParam();
    static long getIntParam2();
    static float getFloatParam();
    static float getFloatParam2();
    static float getBoolParam();
    [Const, Value] static IDLStringView getStrParam();
    [Const] static TestObjectClass getPointerObject01();
    static TestObjectClass getPointerObject02();
    [Const, Ref] static TestObjectClass getRefObject01();
    [Ref] static TestObjectClass getRefObject02();
    [Value] static TestObjectClass getValueObject();
};

enum TestEnumWithinClass {
    "TestEnumClass::e_val"
};

enum TestEnumClassWithinClass {
    "TestEnumClassWithinClass::testEnum"
};

enum TestEnumInNamespace {
    "TestEnumInNamespace::e_namespace_val"
};

enum TestEnumLib {
    "TEST_DEFAULT",
    "TEST_FIRST",
    "TEST_SECOND"
};

// ##########################################

interface ParentClass {
    float addFloatValue(float a, float b);
    boolean invertBoolean(boolean value);
};

interface NormalClass {
    [BoundsChecked] attribute long[] intArray;
    [Value] attribute ReturnClass[] valueArray;
    attribute ReturnClass[] pointerArray;
    attribute long hiddenInt;
    [Value] attribute ReturnClass valueReturnClass;
    attribute ReturnClass pointerReturnClass;
    attribute ReturnClass nullPointerReturnClass;

    static attribute long hiddenInt_static;
    [Value] static attribute ReturnClass valueReturnClass_static;
    static attribute ReturnClass pointerReturnClass_static;
    static attribute ReturnClass nullPointerReturnClass_static;

    void NormalClass();
    void NormalClass(long c, [Ref]ParamData refParamClass);
    void NormalClass(EnumInNamespace nameSpaceEnum);

    long getVersion();
// Emscripten don't allow param by value
//    void NormalClass(ParamData pointerParamData, [Ref]ParamData refParamData, [Value]ParamData valueParamData);

//    void setString(DOMString text);
//    static DOMString addString(DOMString text);
//    [Value] static ReturnClass getStaticReturnValueClass(ParamData paramData);
    [Value]ReturnClass getReturnValueClass(ParamData paramData);

    static long subIntValue(long a, long b, optional long subValue);
    long addIntValue(long a, long b);
    [Ref]ReturnClass getReturnRefClass();
    [Value]ReturnClass getReturnValueObject();
//    ReturnClass getReturnPointerClass();
//    ReturnClass getReturnNullPointerClass();
    void refParam([Ref]ParamData refParamOne, [Ref]ParamData refParamTwo, [Ref]ParamData refParamThree);
//    void pointerParam(ParamData paramData);

    // Emscripten don't allow param by value
//    void valueParam([Value]ParamData paramData);

//    void addIntArrayItems(long [] array);

    void callInterface([Ref]InterfaceClass obj);

    long enumParam(EnumLib value);

    void enumVoidParam(EnumLib value);

    EnumLib enumReturn(long value);

    boolean printText(long dummyParam, [Const]DOMString text);

    void setArray(float[] array);

    void setString([Ref] IDLString text);
    [Ref] IDLString getString();
    [Value] IDLString getStringValue();

    void setVoidParam(any param);
    any getVoidParam();
};
NormalClass implements ParentClass;

interface DefaultParamsClass {
    void DefaultParamsClass(long a, long b, optional float c, optional float d);

    void defaultMethodParams(long a, long b, optional float c, optional float d);
};

[NoDelete]
interface ReturnClass {
    void ReturnClass();

    attribute float value;

    [Operator="=", Ref] ReturnClass copy([Ref]ReturnClass value);
};

interface OperatorClass {
    void OperatorClass();

    attribute float value;

    [Operator="=", Ref] OperatorClass copy([Ref]OperatorClass value);
};

interface ParamData {
    void ParamData();
    attribute long intData;
    attribute float floatData;
};

interface InterfaceClass {
    void onParamCall([Ref]ParamData data);
};

[JSImplementation="InterfaceClass"]
interface InterfaceClassImpl {
    void InterfaceClassImpl();
    [Const] void onParamCall([Ref]ParamData data);
};

interface DefaultInterface {
    void DefaultInterface();
};
DefaultInterface implements InterfaceClass;

enum EnumLib {
    "FIRST",
    "SECOND"
};

enum EnumTwoLib {
    "EnumTwoLib_THIRD",
    "EnumTwoLib_FOURTH"
};

enum EnumWithinClass {
    "NormalClass::e_val"
};

enum EnumClassWithinClass {
    "EnumClassWithinClass::testEnum"
};

enum EnumInNamespace {
    "EnumInNamespace::e_namespace_val"
};